<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of h2d_corresp_ransam</title>
  <meta name="keywords" content="h2d_corresp_ransam">
  <meta name="description" content="H2D_CORRESP_RANSAM Exact 2-D homography (any) from point">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">homogrtb-v0.1.0</a> &gt; h2d_corresp_ransam.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for homogrtb-v0.1.0&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>h2d_corresp_ransam
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>H2D_CORRESP_RANSAM Exact 2-D homography (any) from point</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [bestH bestXt bestParams] = h2d_corresp_ransam(X1_,X2_,tType_,iNum_,bestUsed_,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">H2D_CORRESP_RANSAM Exact 2-D homography (any) from point
correspondence (best transformation selected by random sampling)

 NOTE: This function is highly experimental, it surely works, but
 there are no evidence that it would be better than those more
 elegant methods (e.g. DLT) descibed in the literature in any
 particular application. Read the &quot;NOTE X&quot; section at the end of
 this e-mail.

 [bestH bestXt bestParams] = h2d_corresp_ransam(X1_,X2_,tr_,r_,h_,:)

 Computes the exact 3x3 transformation of type tr_ transforming
 2-D points X1_ to 2-D points X2_ using the correspondence
 information. The method runs r_ iterations where a minimum
 number of random samples are selected and used in the homography
 estimation. The final homography is generated by (weighted)
 average over h_ (set to much less than r_) best estimates
 according to the trasfer error (in X2_ space). For affinity and
 projectivity the h_=1 is the only option.

 NOTE 0: h_ = 1 means that only the best sample is used &lt;RECOMMENDED&gt;

 NOTE 1: do not use any normalisation (they break the isometry
 restriction)

 NOTE 2: This method returns unity transformation if the
 estimation points are detected ill-configured !!

 NOTE 3: This method utilises explicitly estimated transformation
 parameters, which must be provided by the underlying exact
 methods. The method using only the one best could be implemented
 even without the parameters and maybe that is how this really
 should be implemented!

 NOTE 4: SIMILARITY+ is still experimental - for more information
 see the comments inside the exact implementation function.

 Output:
  bestH      -  3x3 transform matrix
  bestXt     -  2xN transformed points (using bestH)
  bestParams - Transformation parameters
               Isometry: 1: theta, 2&amp;3: tx,ty
               Similarity: 1: theta, 2&amp;3: tx,ty, 4: s
               Similarity+: 1: theta, 2&amp;3: tx,ty, 4: delta1, 5: delta2
               Affinity: 1: theta, 2&amp;3: tx,ty, 4: delta1, 5: delta2, 6: beta

 Input:
  X1_    - 3xN coordinates (homogenous)
  X2_    - 3xN coordinates (homogenous)
  tr_    - Homography type
    1   : isometry
    2   : similarity
    2.5 : similarity+
           varargin(1) : scale angle alpha [1]
           varargin(2) : estimation direction (1: from model, 2:to
                         model) [1]
    3   : affinity

  r_     - Number of random repeats (eg. 10, 100, 500...)
  h_     - How many best used in averaging (e.g. 1, 2, 3, 5...)

 See also H2D_CORRESP_EX*.M

 References:

  [1] Kamarainen, J.-K., Paalanen, P., Experimental study on Fast
  2D Homography Estimation From a Few Point Correspondence,
  Research Report, Machine Vision and Pattern Recognition Research
  Group, Lappeenranta University of Technology, Finland, 2008.

 Author(s):
    Joni Kamarainen &lt;Joni.Kamarainen@lut.fi&gt;

 Copyright:

   Homography estimation toolbox is Copyright (C) 2008 by Joni-Kristian
   Kamarainen.

   $Name:  $ $Revision: 1.1 $  $Date: 2008-05-07 12:22:15 $

%</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="h2d_corresp_exaff.html" class="code" title="function [H, theta, tx, ty, delta1, delta2, phi] =h2d_corresp_exaff(X1_,X2_)">h2d_corresp_exaff</a>	H2D_CORRESP_EXAFF Exact 2-D homography (affinity) from point</li><li><a href="h2d_corresp_exiso.html" class="code" title="function [H,theta,tx,ty] = h2d_corresp_exiso(X1_,X2_)">h2d_corresp_exiso</a>	H2D_CORRESP_EXISO Exact 2-D homography (isometry) from point</li><li><a href="h2d_corresp_exsim.html" class="code" title="function [H,theta,tx,ty,s] = h2d_corresp_exsim(X1_,X2_)">h2d_corresp_exsim</a>	H2D_CORRESP_EXSIM Exact 2-D homography (similarity) from point</li><li><a href="h2d_corresp_isvalid.html" class="code" title="function [v] = h2d_corresp_isvalid(X1_,X2_,h_)">h2d_corresp_isvalid</a>	H2D_CORRESP_ISVALID Checks if the given point set is valid</li><li><a href="h2d_iso.html" class="code" title="function [H_E] = h2d_iso(theta_,t_);">h2d_iso</a>	H2D_ISO Construct 2-D homography matrix restricted to</li><li><a href="h2d_sim.html" class="code" title="function [H_S] = h2d_sim(theta_, t_, s_);">h2d_sim</a>	H2D_SIM Construct 2-D homography matrix restricted to</li><li><a href="h2d_trans.html" class="code" title="function [Xn] = h2d_trans(X_, H_);">h2d_trans</a>	H2D_TRANS 2-D homography transformation</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="h2d_corresp.html" class="code" title="function [H] = h2d_corresp(X1_,X2_,varargin)">h2d_corresp</a>	H2D_CORRESP Estimate 2-D homography between point correspondence</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%H2D_CORRESP_RANSAM Exact 2-D homography (any) from point</span>
0002 <span class="comment">%correspondence (best transformation selected by random sampling)</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% NOTE: This function is highly experimental, it surely works, but</span>
0005 <span class="comment">% there are no evidence that it would be better than those more</span>
0006 <span class="comment">% elegant methods (e.g. DLT) descibed in the literature in any</span>
0007 <span class="comment">% particular application. Read the &quot;NOTE X&quot; section at the end of</span>
0008 <span class="comment">% this e-mail.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% [bestH bestXt bestParams] = h2d_corresp_ransam(X1_,X2_,tr_,r_,h_,:)</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Computes the exact 3x3 transformation of type tr_ transforming</span>
0013 <span class="comment">% 2-D points X1_ to 2-D points X2_ using the correspondence</span>
0014 <span class="comment">% information. The method runs r_ iterations where a minimum</span>
0015 <span class="comment">% number of random samples are selected and used in the homography</span>
0016 <span class="comment">% estimation. The final homography is generated by (weighted)</span>
0017 <span class="comment">% average over h_ (set to much less than r_) best estimates</span>
0018 <span class="comment">% according to the trasfer error (in X2_ space). For affinity and</span>
0019 <span class="comment">% projectivity the h_=1 is the only option.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% NOTE 0: h_ = 1 means that only the best sample is used &lt;RECOMMENDED&gt;</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% NOTE 1: do not use any normalisation (they break the isometry</span>
0024 <span class="comment">% restriction)</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% NOTE 2: This method returns unity transformation if the</span>
0027 <span class="comment">% estimation points are detected ill-configured !!</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% NOTE 3: This method utilises explicitly estimated transformation</span>
0030 <span class="comment">% parameters, which must be provided by the underlying exact</span>
0031 <span class="comment">% methods. The method using only the one best could be implemented</span>
0032 <span class="comment">% even without the parameters and maybe that is how this really</span>
0033 <span class="comment">% should be implemented!</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% NOTE 4: SIMILARITY+ is still experimental - for more information</span>
0036 <span class="comment">% see the comments inside the exact implementation function.</span>
0037 <span class="comment">%</span>
0038 <span class="comment">% Output:</span>
0039 <span class="comment">%  bestH      -  3x3 transform matrix</span>
0040 <span class="comment">%  bestXt     -  2xN transformed points (using bestH)</span>
0041 <span class="comment">%  bestParams - Transformation parameters</span>
0042 <span class="comment">%               Isometry: 1: theta, 2&amp;3: tx,ty</span>
0043 <span class="comment">%               Similarity: 1: theta, 2&amp;3: tx,ty, 4: s</span>
0044 <span class="comment">%               Similarity+: 1: theta, 2&amp;3: tx,ty, 4: delta1, 5: delta2</span>
0045 <span class="comment">%               Affinity: 1: theta, 2&amp;3: tx,ty, 4: delta1, 5: delta2, 6: beta</span>
0046 <span class="comment">%</span>
0047 <span class="comment">% Input:</span>
0048 <span class="comment">%  X1_    - 3xN coordinates (homogenous)</span>
0049 <span class="comment">%  X2_    - 3xN coordinates (homogenous)</span>
0050 <span class="comment">%  tr_    - Homography type</span>
0051 <span class="comment">%    1   : isometry</span>
0052 <span class="comment">%    2   : similarity</span>
0053 <span class="comment">%    2.5 : similarity+</span>
0054 <span class="comment">%           varargin(1) : scale angle alpha [1]</span>
0055 <span class="comment">%           varargin(2) : estimation direction (1: from model, 2:to</span>
0056 <span class="comment">%                         model) [1]</span>
0057 <span class="comment">%    3   : affinity</span>
0058 <span class="comment">%</span>
0059 <span class="comment">%  r_     - Number of random repeats (eg. 10, 100, 500...)</span>
0060 <span class="comment">%  h_     - How many best used in averaging (e.g. 1, 2, 3, 5...)</span>
0061 <span class="comment">%</span>
0062 <span class="comment">% See also H2D_CORRESP_EX*.M</span>
0063 <span class="comment">%</span>
0064 <span class="comment">% References:</span>
0065 <span class="comment">%</span>
0066 <span class="comment">%  [1] Kamarainen, J.-K., Paalanen, P., Experimental study on Fast</span>
0067 <span class="comment">%  2D Homography Estimation From a Few Point Correspondence,</span>
0068 <span class="comment">%  Research Report, Machine Vision and Pattern Recognition Research</span>
0069 <span class="comment">%  Group, Lappeenranta University of Technology, Finland, 2008.</span>
0070 <span class="comment">%</span>
0071 <span class="comment">% Author(s):</span>
0072 <span class="comment">%    Joni Kamarainen &lt;Joni.Kamarainen@lut.fi&gt;</span>
0073 <span class="comment">%</span>
0074 <span class="comment">% Copyright:</span>
0075 <span class="comment">%</span>
0076 <span class="comment">%   Homography estimation toolbox is Copyright (C) 2008 by Joni-Kristian</span>
0077 <span class="comment">%   Kamarainen.</span>
0078 <span class="comment">%</span>
0079 <span class="comment">%   $Name:  $ $Revision: 1.1 $  $Date: 2008-05-07 12:22:15 $</span>
0080 <span class="comment">%</span>
0081 <span class="comment">%%</span>
0082 <a name="_sub0" href="#_subfunctions" class="code">function [bestH bestXt bestParams] = h2d_corresp_ransam(X1_,X2_,tType_,iNum_,bestUsed_,varargin)</a>
0083 
0084 <span class="comment">%</span>
0085 <span class="comment">% 1. Init parameters (depends on the homography)</span>
0086 
0087 transferErrs = inf(iNum_,1);
0088 <span class="keyword">switch</span> (tType_)
0089 <span class="comment">% ISOMETRY (theta, tx, ty)</span>
0090 <span class="keyword">case</span> 1,
0091     tParams = inf(iNum_,3);
0092 <span class="comment">% SIMILARITY (theta, tx, ty, s)</span>
0093 <span class="keyword">case</span> 2,
0094     tParams = inf(iNum_,4);
0095 <span class="comment">% SIMILARITYPLUST (theta, tx, ty, delta1, delta2)</span>
0096 <span class="keyword">case</span> 2.5,
0097     tParams = inf(iNum_,5);
0098 <span class="comment">% AFFINITY (theta, tx, ty, delta1, delta2, phi)</span>
0099 <span class="keyword">case</span> 3,
0100     tParams = inf(iNum_,6);
0101 <span class="keyword">otherwise</span>,
0102     error(<span class="string">'Unknown homography type!'</span>);
0103 <span class="keyword">end</span>;
0104 
0105 <span class="comment">%</span>
0106 <span class="comment">% 2. Random loop for estimations</span>
0107 <span class="keyword">for</span> iterInd = 1:iNum_
0108     randInds = randperm(size(X1_,2));
0109     <span class="keyword">switch</span> (tType_)
0110     <span class="comment">% 2.1 ISOMETRY estimation launched</span>
0111     <span class="keyword">case</span> 1,
0112         rX1 = X1_(:,randInds(1:2));
0113         rX2 = X2_(:,randInds(1:2));
0114         <span class="comment">% 2.1.1 Avoid estimations which clearly don't work !!</span>
0115         <span class="keyword">if</span> (<a href="h2d_corresp_isvalid.html" class="code" title="function [v] = h2d_corresp_isvalid(X1_,X2_,h_)">h2d_corresp_isvalid</a>(rX1, rX2, 1))
0116             [H theta tx ty] = <span class="keyword">...</span>
0117                    <a href="h2d_corresp_exiso.html" class="code" title="function [H,theta,tx,ty] = h2d_corresp_exiso(X1_,X2_)">h2d_corresp_exiso</a>(rX1, rX2);
0118         <span class="keyword">else</span>
0119             theta = 0;
0120             tx = 0;
0121             ty = 0;
0122             H = diag([1 1 1]);
0123         <span class="keyword">end</span>;
0124         tParams(iterInd,:) = [theta tx ty];
0125 
0126     <span class="comment">% 2.2 SIMILARITY estimation launched</span>
0127     <span class="keyword">case</span> 2,
0128         rX1 = X1_(:,randInds(1:2));
0129         rX2 = X2_(:,randInds(1:2));
0130         <span class="comment">% 2.2.1 Avoid estimations which clearly don't work !!</span>
0131         <span class="keyword">if</span> (<a href="h2d_corresp_isvalid.html" class="code" title="function [v] = h2d_corresp_isvalid(X1_,X2_,h_)">h2d_corresp_isvalid</a>(rX1, rX2, 2))
0132             [H theta tx ty s] = <span class="keyword">...</span>
0133                             <a href="h2d_corresp_exsim.html" class="code" title="function [H,theta,tx,ty,s] = h2d_corresp_exsim(X1_,X2_)">h2d_corresp_exsim</a>(rX1, rX2);
0134                 <span class="keyword">else</span>
0135             theta = 0;
0136             tx = 0;
0137             ty = 0;
0138             s = 1;
0139             H = diag([1 1 1]);
0140         <span class="keyword">end</span>
0141         tParams(iterInd,:) = [theta tx ty s];
0142 
0143     <span class="comment">% 2.3 SIMILARITYPLUS estimation launched</span>
0144     <span class="keyword">case</span> 2.5,
0145         rX1 = X1_(:,randInds(1:3));
0146         rX2 = X2_(:,randInds(1:3));
0147         <span class="comment">% 2.2.1 Avoid estimations which clearly don't work !!</span>
0148         <span class="keyword">if</span> (homogr_2d_corresp_isvalid(rX1, rX2, 2.5))
0149             [H theta tx ty delta1 delta2] = <span class="keyword">...</span>
0150                       homogr_2d_corresp_exact_similarityplus(<span class="keyword">...</span>
0151                          rX1, rX2, varargin{1}, varargin{2});
0152         <span class="keyword">else</span>
0153             theta = 0;
0154             tx = 0;
0155             ty = 0;
0156             delta1 = 1;
0157             delta2 = 1;
0158             H = diag([1 1 1]);
0159         <span class="keyword">end</span>;
0160         tParams(iterInd,:) = [theta tx ty delta1 delta2];
0161 
0162     <span class="comment">% 2.4 AFFINITY</span>
0163     <span class="keyword">case</span> 3,
0164         rX1 = X1_(:,randInds(1:3));
0165         rX2 = X2_(:,randInds(1:3));
0166         [H theta tx ty delta1 delta2 beta] = <span class="keyword">...</span>
0167                     <a href="h2d_corresp_exaff.html" class="code" title="function [H, theta, tx, ty, delta1, delta2, phi] =h2d_corresp_exaff(X1_,X2_)">h2d_corresp_exaff</a>(rX1, rX2);
0168                     <span class="comment">%homogr_2d_corresp_exact_affinity(rX1, rX2);</span>
0169         <span class="comment">%tParams(iterInd,:) = [theta tx ty delta1 delta2 beta];</span>
0170         snurf = H(1:2, 1:3);
0171         tParams(iterInd,:) = snurf(:);
0172 
0173     <span class="keyword">otherwise</span>,
0174         error(<span class="string">'Unknown homography type!'</span>);
0175     <span class="keyword">end</span>;
0176     Xt = <a href="h2d_trans.html" class="code" title="function [Xn] = h2d_trans(X_, H_);">h2d_trans</a>(X1_,H)';
0177     transferErrs(iterInd) = sum(sqrt(sum((X2_-Xt').^2,1)));
0178 <span class="keyword">end</span>;
0179 
0180 
0181 <span class="comment">%</span>
0182 <span class="comment">% 3. Compute average estimate from best ones</span>
0183 [foo sortInds] = sort(transferErrs);
0184 
0185 <span class="comment">% 3.1 Compute sum rule weights based on errors</span>
0186 
0187 <span class="comment">% Weighted mean does not seem to work any better than the simple mean</span>
0188 bestInds = sortInds(1:bestUsed_);
0189 <span class="comment">%bestWeights = transferErrs(bestInds)/(1000*eps+sum(transferErrs(bestInds)));</span>
0190 <span class="comment">%bestWeights = 1./(1000*eps+bestWeights);</span>
0191 <span class="comment">%bestWeights = bestWeights/sum(bestWeights);</span>
0192 
0193 <span class="comment">% This provides average</span>
0194 bestWeights = ones(size(bestInds))/length(bestInds);
0195 
0196 <span class="comment">% 3.2 Averaging (depends on the homography type)</span>
0197 <span class="keyword">switch</span> (tType_)
0198 <span class="comment">% 2.3.2.1 ISOMETRY averaging</span>
0199 <span class="keyword">case</span> 1,
0200     theta = sum(bestWeights.*tParams(bestInds,1));
0201     tx = sum(bestWeights.*tParams(bestInds,2));
0202     ty = sum(bestWeights.*tParams(bestInds,3));
0203     bestH = <a href="h2d_iso.html" class="code" title="function [H_E] = h2d_iso(theta_,t_);">h2d_iso</a>(theta, [tx ty]);
0204     bestParams = [theta tx ty];
0205 <span class="comment">% 2.3.2.2 SIMILARITY averaging</span>
0206 <span class="keyword">case</span> 2,
0207     theta = sum(bestWeights.*tParams(bestInds,1));
0208     tx = sum(bestWeights.*tParams(bestInds,2));
0209     ty = sum(bestWeights.*tParams(bestInds,3));
0210     s = sum(bestWeights.*tParams(bestInds,4));
0211     bestH = <a href="h2d_sim.html" class="code" title="function [H_S] = h2d_sim(theta_, t_, s_);">h2d_sim</a>(theta, [tx ty], s);
0212     bestParams = [theta tx ty s];
0213 <span class="comment">% 2.3.2.3 SIMILARITYPLUS averaging</span>
0214 <span class="keyword">case</span> 2.5,
0215     theta = sum(bestWeights.*tParams(bestInds,1));
0216     tx = sum(bestWeights.*tParams(bestInds,2));
0217     ty = sum(bestWeights.*tParams(bestInds,3));
0218     delta1 = sum(bestWeights.*tParams(bestInds,4));
0219     delta2 = sum(bestWeights.*tParams(bestInds,5));
0220     bestH = homogr_2d_similarityplus(theta, [tx ty], delta1, delta2, <span class="keyword">...</span>
0221                                                varargin{1}, varargin{2});
0222     bestParams = [theta tx ty delta1 delta2];
0223 <span class="comment">% AFFINITY</span>
0224 <span class="keyword">case</span> 3
0225     <span class="comment">%  For some reason the parametric decomposition introduces error</span>
0226     <span class="comment">%theta = sum(bestWeights.*tParams(bestInds,1));</span>
0227     <span class="comment">%tx = sum(bestWeights.*tParams(bestInds,2));</span>
0228     <span class="comment">%ty = sum(bestWeights.*tParams(bestInds,3));</span>
0229     <span class="comment">%delta1 = sum(bestWeights.*tParams(bestInds,4));</span>
0230     <span class="comment">%delta2 = sum(bestWeights.*tParams(bestInds,5));</span>
0231     <span class="comment">%beta = sum(bestWeights.*tParams(bestInds,6));</span>
0232     <span class="comment">%bestH = homogr_2d_similarityplus(theta, [tx ty], delta1, delta2, ...</span>
0233     <span class="comment">%                                                            beta, 1);</span>
0234     bestParams = [theta tx ty delta1 delta2 beta];
0235     snurf = tParams(bestInds(1),:);
0236     bestH = [reshape(snurf, 2, 3); 0 0 1];
0237 <span class="keyword">otherwise</span>,
0238     error(<span class="string">'Unknown homography type!'</span>);
0239 <span class="keyword">end</span>;
0240 
0241 bestXt = <a href="h2d_trans.html" class="code" title="function [Xn] = h2d_trans(X_, H_);">h2d_trans</a>(X1_,bestH)';</pre></div>
<hr><address>Generated on Wed 07-May-2008 15:22:47 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>