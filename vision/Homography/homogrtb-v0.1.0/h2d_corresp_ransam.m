%H2D_CORRESP_RANSAM Exact 2-D homography (any) from point
%correspondence (best transformation selected by random sampling)
%
% NOTE: This function is highly experimental, it surely works, but
% there are no evidence that it would be better than those more
% elegant methods (e.g. DLT) descibed in the literature in any
% particular application. Read the "NOTE X" section at the end of
% this e-mail.
%
% [bestH bestXt bestParams] = h2d_corresp_ransam(X1_,X2_,tr_,r_,h_,:)
%
% Computes the exact 3x3 transformation of type tr_ transforming
% 2-D points X1_ to 2-D points X2_ using the correspondence
% information. The method runs r_ iterations where a minimum
% number of random samples are selected and used in the homography
% estimation. The final homography is generated by (weighted)
% average over h_ (set to much less than r_) best estimates
% according to the trasfer error (in X2_ space). For affinity and
% projectivity the h_=1 is the only option.
%
% NOTE 0: h_ = 1 means that only the best sample is used <RECOMMENDED>
%
% NOTE 1: do not use any normalisation (they break the isometry
% restriction)
%
% NOTE 2: This method returns unity transformation if the
% estimation points are detected ill-configured !!
%
% NOTE 3: This method utilises explicitly estimated transformation
% parameters, which must be provided by the underlying exact
% methods. The method using only the one best could be implemented
% even without the parameters and maybe that is how this really
% should be implemented!
%
% NOTE 4: SIMILARITY+ is still experimental - for more information
% see the comments inside the exact implementation function.
%
% Output:
%  bestH      -  3x3 transform matrix
%  bestXt     -  2xN transformed points (using bestH)
%  bestParams - Transformation parameters
%               Isometry: 1: theta, 2&3: tx,ty
%               Similarity: 1: theta, 2&3: tx,ty, 4: s
%               Similarity+: 1: theta, 2&3: tx,ty, 4: delta1, 5: delta2
%               Affinity: 1: theta, 2&3: tx,ty, 4: delta1, 5: delta2, 6: beta
%
% Input:
%  X1_    - 3xN coordinates (homogenous)
%  X2_    - 3xN coordinates (homogenous)
%  tr_    - Homography type
%	1   : isometry
%	2   : similarity
%	2.5 : similarity+
%           varargin(1) : scale angle alpha [1]
%           varargin(2) : estimation direction (1: from model, 2:to
%                         model) [1]
%	3   : affinity
%
%  r_     - Number of random repeats (eg. 10, 100, 500...)
%  h_     - How many best used in averaging (e.g. 1, 2, 3, 5...)
%
% See also H2D_CORRESP_EX*.M
%
% References:
%
%  [1] Kamarainen, J.-K., Paalanen, P., Experimental study on Fast
%  2D Homography Estimation From a Few Point Correspondence,
%  Research Report, Machine Vision and Pattern Recognition Research
%  Group, Lappeenranta University of Technology, Finland, 2008.
%
% Author(s):
%    Joni Kamarainen <Joni.Kamarainen@lut.fi>
%
% Copyright:
%
%   Homography estimation toolbox is Copyright (C) 2008 by Joni-Kristian
%   Kamarainen.
%
%   $Name:  $ $Revision: 1.1 $  $Date: 2008-05-07 12:22:15 $
%
%%
function [bestH bestXt bestParams] = h2d_corresp_ransam(X1_,X2_,tType_,iNum_,bestUsed_,varargin)

%
% 1. Init parameters (depends on the homography)

transferErrs = inf(iNum_,1);
switch (tType_)
% ISOMETRY (theta, tx, ty)
case 1,
	tParams = inf(iNum_,3);
% SIMILARITY (theta, tx, ty, s)
case 2,
	tParams = inf(iNum_,4);
% SIMILARITYPLUST (theta, tx, ty, delta1, delta2)
case 2.5,
	tParams = inf(iNum_,5);
% AFFINITY (theta, tx, ty, delta1, delta2, phi)
case 3,
	tParams = inf(iNum_,6);
otherwise,
	error('Unknown homography type!');
end;

%
% 2. Random loop for estimations
for iterInd = 1:iNum_
	randInds = randperm(size(X1_,2));
	switch (tType_)
	% 2.1 ISOMETRY estimation launched
	case 1,
		rX1 = X1_(:,randInds(1:2));
		rX2 = X2_(:,randInds(1:2));
		% 2.1.1 Avoid estimations which clearly don't work !!
		if (h2d_corresp_isvalid(rX1, rX2, 1))
			[H theta tx ty] = ...
			       h2d_corresp_exiso(rX1, rX2);
		else
			theta = 0;
			tx = 0;
			ty = 0;
			H = diag([1 1 1]);
		end;
		tParams(iterInd,:) = [theta tx ty];

	% 2.2 SIMILARITY estimation launched
	case 2,
		rX1 = X1_(:,randInds(1:2));
		rX2 = X2_(:,randInds(1:2));
		% 2.2.1 Avoid estimations which clearly don't work !!
		if (h2d_corresp_isvalid(rX1, rX2, 2))
			[H theta tx ty s] = ...
                            h2d_corresp_exsim(rX1, rX2);
                else
			theta = 0;
			tx = 0;
			ty = 0;
			s = 1;
			H = diag([1 1 1]);
		end
		tParams(iterInd,:) = [theta tx ty s];

	% 2.3 SIMILARITYPLUS estimation launched
	case 2.5,
		rX1 = X1_(:,randInds(1:3));
		rX2 = X2_(:,randInds(1:3));
		% 2.2.1 Avoid estimations which clearly don't work !!
		if (homogr_2d_corresp_isvalid(rX1, rX2, 2.5))
			[H theta tx ty delta1 delta2] = ...
			          homogr_2d_corresp_exact_similarityplus(...
			             rX1, rX2, varargin{1}, varargin{2});
		else
			theta = 0;
			tx = 0;
			ty = 0;
			delta1 = 1;
			delta2 = 1;
			H = diag([1 1 1]);
		end;
		tParams(iterInd,:) = [theta tx ty delta1 delta2];

	% 2.4 AFFINITY
	case 3,
		rX1 = X1_(:,randInds(1:3));
		rX2 = X2_(:,randInds(1:3));
		[H theta tx ty delta1 delta2 beta] = ...
                    h2d_corresp_exaff(rX1, rX2);
                    %homogr_2d_corresp_exact_affinity(rX1, rX2);
		%tParams(iterInd,:) = [theta tx ty delta1 delta2 beta];
		snurf = H(1:2, 1:3);
		tParams(iterInd,:) = snurf(:);

	otherwise,
		error('Unknown homography type!');
	end;
	Xt = h2d_trans(X1_,H)';
	transferErrs(iterInd) = sum(sqrt(sum((X2_-Xt').^2,1)));
end;


%
% 3. Compute average estimate from best ones
[foo sortInds] = sort(transferErrs);

% 3.1 Compute sum rule weights based on errors

% Weighted mean does not seem to work any better than the simple mean 
bestInds = sortInds(1:bestUsed_);
%bestWeights = transferErrs(bestInds)/(1000*eps+sum(transferErrs(bestInds)));
%bestWeights = 1./(1000*eps+bestWeights);
%bestWeights = bestWeights/sum(bestWeights);

% This provides average
bestWeights = ones(size(bestInds))/length(bestInds);

% 3.2 Averaging (depends on the homography type)
switch (tType_)
% 2.3.2.1 ISOMETRY averaging
case 1,
	theta = sum(bestWeights.*tParams(bestInds,1));
	tx = sum(bestWeights.*tParams(bestInds,2));
	ty = sum(bestWeights.*tParams(bestInds,3));
	bestH = h2d_iso(theta, [tx ty]);
	bestParams = [theta tx ty];
% 2.3.2.2 SIMILARITY averaging
case 2,
	theta = sum(bestWeights.*tParams(bestInds,1));
	tx = sum(bestWeights.*tParams(bestInds,2));
	ty = sum(bestWeights.*tParams(bestInds,3));
	s = sum(bestWeights.*tParams(bestInds,4));
	bestH = h2d_sim(theta, [tx ty], s);
	bestParams = [theta tx ty s];
% 2.3.2.3 SIMILARITYPLUS averaging
case 2.5,
	theta = sum(bestWeights.*tParams(bestInds,1));
	tx = sum(bestWeights.*tParams(bestInds,2));
	ty = sum(bestWeights.*tParams(bestInds,3));
	delta1 = sum(bestWeights.*tParams(bestInds,4));
	delta2 = sum(bestWeights.*tParams(bestInds,5));
	bestH = homogr_2d_similarityplus(theta, [tx ty], delta1, delta2, ...
	                                           varargin{1}, varargin{2});
	bestParams = [theta tx ty delta1 delta2];
% AFFINITY
case 3
	%  For some reason the parametric decomposition introduces error
	%theta = sum(bestWeights.*tParams(bestInds,1));
	%tx = sum(bestWeights.*tParams(bestInds,2));
	%ty = sum(bestWeights.*tParams(bestInds,3));
	%delta1 = sum(bestWeights.*tParams(bestInds,4));
	%delta2 = sum(bestWeights.*tParams(bestInds,5));
	%beta = sum(bestWeights.*tParams(bestInds,6));
	%bestH = homogr_2d_similarityplus(theta, [tx ty], delta1, delta2, ...
	%                                                            beta, 1);
	bestParams = [theta tx ty delta1 delta2 beta];
	snurf = tParams(bestInds(1),:);
	bestH = [reshape(snurf, 2, 3); 0 0 1];
otherwise,
	error('Unknown homography type!');
end;

bestXt = h2d_trans(X1_,bestH)';
